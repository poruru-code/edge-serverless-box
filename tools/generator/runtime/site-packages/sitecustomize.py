import os
import json
import time
import base64
import threading
import boto3
from datetime import datetime, timezone
from botocore.config import Config

# --- Globals & Originals ---
_original_boto3_client = boto3.client
_trace_context = threading.local()


# --- Config ---
LOG_LEVEL_MAP = {"DEBUG": 10, "INFO": 20, "WARNING": 30, "ERROR": 40, "CRITICAL": 50}

SERVICE_CONFIG = {
    "s3": {
        "env_var": "S3_ENDPOINT",
        "config": Config(s3={"addressing_style": "path"}, signature_version="s3v4"),
    },
    "dynamodb": {
        "env_var": "DYNAMODB_ENDPOINT",
        "config": Config(
            retries={"max_attempts": 10, "mode": "standard"}, connect_timeout=5, read_timeout=5
        ),
    },
    "lambda": {
        "env_var": "GATEWAY_INTERNAL_URL",
        "config": Config(
            retries={"max_attempts": 10, "mode": "standard"}, connect_timeout=5, read_timeout=5
        ),
    },
}

print(f"[sitecustomize] Loaded. boto3 ID: {id(boto3)}")


# --- Helpers ---


def _get_iso8601_ms(ts_ms):
    dt = datetime.fromtimestamp(ts_ms / 1000.0, tz=timezone.utc)
    return dt.isoformat(timespec="milliseconds")


def _estimate_container_name(log_group):
    if not log_group.startswith("/lambda/"):
        return "unknown"
    func_name = log_group[len("/lambda/") :]
    if func_name.endswith("-test"):
        func_name = func_name[:-5]
    name = f"lambda-{func_name}"
    return name[1:] if name.startswith("/") else name


def _get_current_trace_id():
    """現在の Trace ID を取得 (動的キャプチャ > 環境変数)"""
    return getattr(_trace_context, "current_trace_id", None) or os.environ.get("_X_AMZN_TRACE_ID")


def _sync_to_environ(trace_id):
    """取得した Trace ID を os.environ にも同期 (boto3標準の動作を補助)"""
    if not trace_id:
        return
    os.environ["_X_AMZN_TRACE_ID"] = trace_id


# --- Logic: ClientContext Injection (For RIE) ---


def _inject_client_context_hook(params, **kwargs):
    """
    [重要] Lambda RIE 対策
    RIE は HTTP ヘッダーの X-Amzn-Trace-Id を無視するため、
    ClientContext の custom 領域に trace_id を埋め込んで渡す。
    イベント: provide-client-params.lambda.Invoke
    """
    trace_id = _get_current_trace_id()
    if not trace_id:
        return

    # 既存の ClientContext をデコード (あれば)
    ctx_data = {}
    if "ClientContext" in params:
        try:
            ctx_data = json.loads(base64.b64decode(params["ClientContext"]).decode("utf-8"))
        except Exception as e:
            print(f"[sitecustomize] Warning: Failed to decode existing ClientContext: {e}")

    # custom 領域に trace_id を注入
    if "custom" not in ctx_data:
        ctx_data["custom"] = {}

    # 既にセットされていなければセットする
    if "trace_id" not in ctx_data["custom"]:
        ctx_data["custom"]["trace_id"] = trace_id

        # 再エンコードして params を書き換え
        json_str = json.dumps(ctx_data)
        b64_str = base64.b64encode(json_str.encode("utf-8")).decode("utf-8")
        params["ClientContext"] = b64_str

        print(f"[sitecustomize] Injected Trace ID into ClientContext for RIE: {trace_id}")


# --- Logic: Log Patching ---


def _patched_put_log_events(self, **kwargs):
    try:
        log_group = kwargs.get("logGroupName", "unknown")
        log_stream = kwargs.get("logStreamName", "unknown")
        log_events = kwargs.get("logEvents", [])
        container_name = _estimate_container_name(log_group)

        current_threshold = LOG_LEVEL_MAP.get(os.environ.get("LOG_LEVEL", "INFO").upper(), 20)

        for event in log_events:
            msg = event.get("message", "")
            ts_ms = event.get("timestamp", int(time.time() * 1000))

            level = "INFO"
            clean_msg = msg
            for lvl in LOG_LEVEL_MAP.keys():
                if msg.startswith(f"[{lvl}]"):
                    level = lvl
                    clean_msg = msg[len(f"[{lvl}]") :].lstrip()
                    break

            if LOG_LEVEL_MAP.get(level, 20) < current_threshold:
                continue

            log_entry = {
                "_time": _get_iso8601_ms(ts_ms),
                "level": level,
                "message": clean_msg,
                "log_group": log_group,
                "log_stream": log_stream,
                "logger": "boto3.mock",
                "container_name": container_name,
                "trace_id": _get_current_trace_id(),
            }
            print(json.dumps(log_entry, ensure_ascii=False))

        return {"nextSequenceToken": "mock-token"}
    except Exception as e:
        print(f"[sitecustomize] Error in _patched_put_log_events: {e}")
        raise e


# --- Logic: Client Factory Patch ---


def _patched_boto3_client(service_name, *args, **kwargs):
    try:
        # Logs: 完全ローカルモック
        if service_name == "logs":
            print("[sitecustomize] Creating original boto3 client for logs (local mock mode)...")
            client = _original_boto3_client(service_name, *args, **kwargs)
            _original_make_api_call = client._make_api_call

            def _patched_make_api_call(operation_name, api_params):
                if operation_name == "PutLogEvents":
                    return _patched_put_log_events(client, **api_params)
                if operation_name in (
                    "CreateLogGroup",
                    "CreateLogStream",
                    "DeleteLogGroup",
                    "DeleteLogStream",
                ):
                    return {}
                if operation_name == "DescribeLogGroups":
                    return {"logGroups": []}
                if operation_name == "DescribeLogStreams":
                    return {"logStreams": []}
                return _original_make_api_call(operation_name, api_params)

            client._make_api_call = _patched_make_api_call
            return client

        # Other Services: Endpoint Redirection & Trace Injection
        service_cfg = SERVICE_CONFIG.get(service_name)
        if service_cfg:
            endpoint = os.environ.get(service_cfg["env_var"])
            if endpoint:
                kwargs["endpoint_url"] = endpoint
                kwargs["verify"] = False
                if service_cfg["config"]:
                    existing = kwargs.get("config")
                    kwargs["config"] = (
                        existing.merge(service_cfg["config"]) if existing else service_cfg["config"]
                    )
                print(f"[sitecustomize] Redirecting {service_name} to {endpoint}")

            client = _original_boto3_client(service_name, *args, **kwargs)

            # --- Lambda用フック登録 ---
            if service_name == "lambda":
                # provide-client-params はパラメータ検証前に発火するため、引数書き換えに最適
                client.meta.events.register(
                    "provide-client-params.lambda.Invoke", _inject_client_context_hook
                )
                print("[sitecustomize] Registered ClientContext hook for lambda.Invoke")

            return client

        return _original_boto3_client(service_name, *args, **kwargs)

    except Exception as e:
        print(f"[sitecustomize] Error in _patched_boto3_client for {service_name}: {e}")
        import traceback

        traceback.print_exc()
        raise e


# --- Apply Patches ---

# 1. boto3.client (Factory: ClientContextフックの登録とエンドポイント変更)
boto3.client = _patched_boto3_client

print("[sitecustomize] All patches applied. RIE Trace ID bridge enabled.")
